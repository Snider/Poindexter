{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Poindexter","text":"<p>Welcome to the Poindexter Go library documentation!</p>"},{"location":"#overview","title":"Overview","text":"<p>Poindexter is a Go library package licensed under EUPL-1.2.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Simple and easy to use</li> <li>Comprehensive sorting utilities with custom comparators</li> <li>Generic sorting functions with type safety</li> <li>Binary search capabilities</li> <li>Well-documented API</li> <li>Comprehensive test coverage</li> <li>Cross-platform support</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Install the library:</p> <pre><code>go get github.com/Snider/Poindexter\n</code></pre> <p>Use it in your code:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"github.com/Snider/Poindexter\"\n)\n\nfunc main() {\n    fmt.Println(poindexter.Hello(\"World\"))\n    fmt.Println(\"Version:\", poindexter.Version())\n}\n</code></pre>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the European Union Public Licence v1.2 (EUPL-1.2).</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions are welcome! Please feel free to submit a Pull Request.</p>"},{"location":"#examples","title":"Examples","text":"<ul> <li>Find the best (lowest\u2011ping) DHT peer using KDTree: Best Ping Peer (DHT)</li> <li>Multi-dimensional neighbor search over ping, hops, geo, and score: Multi-Dimensional KDTree (DHT)</li> </ul>"},{"location":"#performance","title":"Performance","text":"<ul> <li>Benchmark methodology and guidance: Performance</li> </ul>"},{"location":"api/","title":"API Reference","text":"<p>Complete API documentation for the Poindexter library.</p>"},{"location":"api/#core-functions","title":"Core Functions","text":""},{"location":"api/#version","title":"Version","text":"<pre><code>func Version() string\n</code></pre> <p>Returns the current version of the library.</p> <p>Returns: - <code>string</code>: The version string (e.g., \"0.3.0\")</p> <p>Example:</p> <pre><code>version := poindexter.Version()\nfmt.Println(version) // Output: 0.3.0\n</code></pre>"},{"location":"api/#hello","title":"Hello","text":"<pre><code>func Hello(name string) string\n</code></pre> <p>Returns a greeting message.</p> <p>Parameters: - <code>name</code> (string): The name to greet. If empty, defaults to \"World\"</p> <p>Returns: - <code>string</code>: A greeting message</p> <p>Examples:</p> <pre><code>// Greet the world\nmessage := poindexter.Hello(\"\")\nfmt.Println(message) // Output: Hello, World!\n\n// Greet a specific person\nmessage = poindexter.Hello(\"Alice\")\nfmt.Println(message) // Output: Hello, Alice!\n</code></pre>"},{"location":"api/#sorting-functions","title":"Sorting Functions","text":""},{"location":"api/#basic-sorting","title":"Basic Sorting","text":""},{"location":"api/#sortints","title":"SortInts","text":"<pre><code>func SortInts(data []int)\n</code></pre> <p>Sorts a slice of integers in ascending order in place.</p> <p>Example:</p> <pre><code>numbers := []int{3, 1, 4, 1, 5, 9}\npoindexter.SortInts(numbers)\nfmt.Println(numbers) // Output: [1 1 3 4 5 9]\n</code></pre>"},{"location":"api/#sortintsdescending","title":"SortIntsDescending","text":"<pre><code>func SortIntsDescending(data []int)\n</code></pre> <p>Sorts a slice of integers in descending order in place.</p> <p>Example:</p> <pre><code>numbers := []int{3, 1, 4, 1, 5, 9}\npoindexter.SortIntsDescending(numbers)\nfmt.Println(numbers) // Output: [9 5 4 3 1 1]\n</code></pre>"},{"location":"api/#sortstrings","title":"SortStrings","text":"<pre><code>func SortStrings(data []string)\n</code></pre> <p>Sorts a slice of strings in ascending order in place.</p> <p>Example:</p> <pre><code>words := []string{\"banana\", \"apple\", \"cherry\"}\npoindexter.SortStrings(words)\nfmt.Println(words) // Output: [apple banana cherry]\n</code></pre>"},{"location":"api/#sortstringsdescending","title":"SortStringsDescending","text":"<pre><code>func SortStringsDescending(data []string)\n</code></pre> <p>Sorts a slice of strings in descending order in place.</p>"},{"location":"api/#sortfloat64s","title":"SortFloat64s","text":"<pre><code>func SortFloat64s(data []float64)\n</code></pre> <p>Sorts a slice of float64 values in ascending order in place.</p>"},{"location":"api/#sortfloat64sdescending","title":"SortFloat64sDescending","text":"<pre><code>func SortFloat64sDescending(data []float64)\n</code></pre> <p>Sorts a slice of float64 values in descending order in place.</p>"},{"location":"api/#advanced-sorting","title":"Advanced Sorting","text":""},{"location":"api/#sortby","title":"SortBy","text":"<pre><code>func SortBy[T any](data []T, less func(i, j int) bool)\n</code></pre> <p>Sorts a slice using a custom comparison function.</p> <p>Parameters: - <code>data</code>: The slice to sort - <code>less</code>: A function that returns true if data[i] should come before data[j]</p> <p>Example:</p> <pre><code>type Person struct {\n    Name string\n    Age  int\n}\n\npeople := []Person{\n    {\"Alice\", 30},\n    {\"Bob\", 25},\n    {\"Charlie\", 35},\n}\n\n// Sort by age\npoindexter.SortBy(people, func(i, j int) bool {\n    return people[i].Age &lt; people[j].Age\n})\n// Result: [Bob(25) Alice(30) Charlie(35)]\n</code></pre>"},{"location":"api/#sortbykey","title":"SortByKey","text":"<pre><code>func SortByKey[T any, K int | float64 | string](data []T, key func(T) K)\n</code></pre> <p>Sorts a slice by extracting a comparable key from each element in ascending order.</p> <p>Parameters: - <code>data</code>: The slice to sort - <code>key</code>: A function that extracts a sortable key from each element</p> <p>Example:</p> <pre><code>type Product struct {\n    Name  string\n    Price float64\n}\n\nproducts := []Product{\n    {\"Apple\", 1.50},\n    {\"Banana\", 0.75},\n    {\"Cherry\", 3.00},\n}\n\n// Sort by price\npoindexter.SortByKey(products, func(p Product) float64 {\n    return p.Price\n})\n// Result: [Banana(0.75) Apple(1.50) Cherry(3.00)]\n</code></pre>"},{"location":"api/#sortbykeydescending","title":"SortByKeyDescending","text":"<pre><code>func SortByKeyDescending[T any, K int | float64 | string](data []T, key func(T) K)\n</code></pre> <p>Sorts a slice by extracting a comparable key from each element in descending order.</p> <p>Example:</p> <pre><code>type Student struct {\n    Name  string\n    Score int\n}\n\nstudents := []Student{\n    {\"Alice\", 85},\n    {\"Bob\", 92},\n    {\"Charlie\", 78},\n}\n\n// Sort by score descending\npoindexter.SortByKeyDescending(students, func(s Student) int {\n    return s.Score\n})\n// Result: [Bob(92) Alice(85) Charlie(78)]\n</code></pre>"},{"location":"api/#checking-if-sorted","title":"Checking if Sorted","text":""},{"location":"api/#issorted","title":"IsSorted","text":"<pre><code>func IsSorted(data []int) bool\n</code></pre> <p>Checks if a slice of integers is sorted in ascending order.</p>"},{"location":"api/#issortedstrings","title":"IsSortedStrings","text":"<pre><code>func IsSortedStrings(data []string) bool\n</code></pre> <p>Checks if a slice of strings is sorted in ascending order.</p>"},{"location":"api/#issortedfloat64s","title":"IsSortedFloat64s","text":"<pre><code>func IsSortedFloat64s(data []float64) bool\n</code></pre> <p>Checks if a slice of float64 values is sorted in ascending order.</p>"},{"location":"api/#binary-search","title":"Binary Search","text":""},{"location":"api/#binarysearch","title":"BinarySearch","text":"<pre><code>func BinarySearch(data []int, target int) int\n</code></pre> <p>Performs a binary search on a sorted slice of integers.</p> <p>Parameters: - <code>data</code>: A sorted slice of integers - <code>target</code>: The value to search for</p> <p>Returns: - <code>int</code>: The index where target is found, or -1 if not found</p> <p>Example:</p> <pre><code>numbers := []int{1, 3, 5, 7, 9, 11}\nindex := poindexter.BinarySearch(numbers, 7)\nfmt.Println(index) // Output: 3\n</code></pre>"},{"location":"api/#binarysearchstrings","title":"BinarySearchStrings","text":"<pre><code>func BinarySearchStrings(data []string, target string) int\n</code></pre> <p>Performs a binary search on a sorted slice of strings.</p> <p>Parameters: - <code>data</code>: A sorted slice of strings - <code>target</code>: The value to search for</p> <p>Returns: - <code>int</code>: The index where target is found, or -1 if not found</p>"},{"location":"api/#kdtree-helpers","title":"KDTree Helpers","text":"<p>Poindexter provides helpers to build normalized, weighted KD points from your own records. These functions min\u2013max normalize each axis over your dataset, optionally invert axes where higher is better (to turn them into \u201clower cost\u201d), and apply per\u2011axis weights.</p> <pre><code>func Build2D[T any](\n    items []T,\n    id func(T) string,\n    f1, f2 func(T) float64,\n    weights [2]float64,\n    invert [2]bool,\n) ([]KDPoint[T], error)\n\nfunc Build3D[T any](\n    items []T,\n    id func(T) string,\n    f1, f2, f3 func(T) float64,\n    weights [3]float64,\n    invert [3]bool,\n) ([]KDPoint[T], error)\n\nfunc Build4D[T any](\n    items []T,\n    id func(T) string,\n    f1, f2, f3, f4 func(T) float64,\n    weights [4]float64,\n    invert [4]bool,\n) ([]KDPoint[T], error)\n</code></pre> <p>Example (4D over ping, hops, geo, score):</p> <pre><code>// weights and inversion: flip score so higher is better \u2192 lower cost\nweights := [4]float64{1.0, 0.7, 0.2, 1.2}\ninvert  := [4]bool{false, false, false, true}\n\npts, err := poindexter.Build4D(\n    peers,\n    func(p Peer) string { return p.ID },\n    func(p Peer) float64 { return p.PingMS },\n    func(p Peer) float64 { return p.Hops },\n    func(p Peer) float64 { return p.GeoKM },\n    func(p Peer) float64 { return p.Score },\n    weights, invert,\n)\nif err != nil { panic(err) }\n\nkdt, _ := poindexter.NewKDTree(pts, poindexter.WithMetric(poindexter.EuclideanDistance{}))\nbest, dist, _ := kdt.Nearest([]float64{0, 0, 0, 0})\n</code></pre> <p>Notes: - Keep and reuse your normalization parameters (min/max) if you need consistency across updates; otherwise rebuild points when the candidate set changes. - Use <code>invert</code> to turn \u201chigher is better\u201d features (like scores) into lower costs for distance calculations.</p>"},{"location":"api/#kdtree-constructors-and-errors","title":"KDTree Constructors and Errors","text":""},{"location":"api/#newkdtree","title":"NewKDTree","text":"<pre><code>func NewKDTree[T any](pts []KDPoint[T], opts ...KDOption) (*KDTree[T], error)\n</code></pre> <p>Build a KDTree from the provided points. All points must have the same dimensionality (&gt; 0) and IDs (if provided) must be unique.</p> <p>Possible errors: - <code>ErrEmptyPoints</code>: no points provided - <code>ErrZeroDim</code>: dimension must be at least 1 - <code>ErrDimMismatch</code>: inconsistent dimensionality among points - <code>ErrDuplicateID</code>: duplicate point ID encountered</p>"},{"location":"api/#newkdtreefromdim","title":"NewKDTreeFromDim","text":"<pre><code>func NewKDTreeFromDim[T any](dim int, opts ...KDOption) (*KDTree[T], error)\n</code></pre> <p>Construct an empty KDTree with the given dimension, then populate later via <code>Insert</code>.</p>"},{"location":"api/#kdtree-notes-complexity-ties-concurrency","title":"KDTree Notes: Complexity, Ties, Concurrency","text":"<ul> <li>Complexity: current implementation uses O(n) linear scans for queries (<code>Nearest</code>, <code>KNearest</code>, <code>Radius</code>). Inserts are O(1) amortized. Deletes by ID are O(1) using swap-delete (order not preserved).</li> <li>Tie ordering: when multiple neighbors have the same distance, ordering of ties is arbitrary and not stable between calls.</li> <li>Concurrency: KDTree is not safe for concurrent mutation. Wrap with a mutex or share immutable snapshots for read-mostly workloads.</li> </ul> <p>See runnable examples in the repository <code>examples/</code> and the docs pages for 1D DHT and multi-dimensional KDTree usage.</p>"},{"location":"api/#kdtree-normalization-stats-reuse-across-updates","title":"KDTree Normalization Stats (reuse across updates)","text":"<p>To keep normalization consistent across dynamic updates, compute per\u2011axis min/max once and reuse it to build points later. This avoids drift when the candidate set changes.</p>"},{"location":"api/#types","title":"Types","text":"<pre><code>// AxisStats holds the min/max observed for a single axis.\ntype AxisStats struct {\n    Min float64\n    Max float64\n}\n\n// NormStats holds per\u2011axis normalisation stats; for D dims, Stats has length D.\ntype NormStats struct {\n    Stats []AxisStats\n}\n</code></pre>"},{"location":"api/#compute-normalization-stats","title":"Compute normalization stats","text":"<pre><code>func ComputeNormStats2D[T any](items []T, f1, f2 func(T) float64) NormStats\nfunc ComputeNormStats3D[T any](items []T, f1, f2, f3 func(T) float64) NormStats\nfunc ComputeNormStats4D[T any](items []T, f1, f2, f3, f4 func(T) float64) NormStats\n</code></pre>"},{"location":"api/#build-with-precomputed-stats","title":"Build with precomputed stats","text":"<pre><code>func Build2DWithStats[T any](\n    items []T,\n    id func(T) string,\n    f1, f2 func(T) float64,\n    weights [2]float64,\n    invert [2]bool,\n    stats NormStats,\n) ([]KDPoint[T], error)\n\nfunc Build3DWithStats[T any](\n    items []T,\n    id func(T) string,\n    f1, f2, f3 func(T) float64,\n    weights [3]float64,\n    invert [3]bool,\n    stats NormStats,\n) ([]KDPoint[T], error)\n\nfunc Build4DWithStats[T any](\n    items []T,\n    id func(T) string,\n    f1, f2, f3, f4 func(T) float64,\n    weights [4]float64,\n    invert [4]bool,\n    stats NormStats,\n) ([]KDPoint[T], error)\n</code></pre>"},{"location":"api/#example-2d","title":"Example (2D)","text":"<pre><code>// Compute stats once over your baseline set\nstats := poindexter.ComputeNormStats2D(peers,\n    func(p Peer) float64 { return p.PingMS },\n    func(p Peer) float64 { return p.Hops },\n)\n\n// Build points using those stats (now or later)\npts, _ := poindexter.Build2DWithStats(\n    peers,\n    func(p Peer) string { return p.ID },\n    func(p Peer) float64 { return p.PingMS },\n    func(p Peer) float64 { return p.Hops },\n    [2]float64{1,1}, [2]bool{false,false}, stats,\n)\n</code></pre> <p>Notes: - If <code>min==max</code> for an axis, normalized value is <code>0</code> for that axis. - <code>invert[i]</code> flips the normalized axis as <code>1 - n</code> before applying <code>weights[i]</code>. - These helpers mirror <code>Build2D/3D/4D</code>, but use your provided <code>NormStats</code> instead of recomputing from the items slice.</p>"},{"location":"api/#kdtree-normalization-helpers-nd","title":"KDTree Normalization Helpers (N\u2011D)","text":"<p>Poindexter includes helpers to build KD points from arbitrary dimensions.</p> <pre><code>func BuildND[T any](\n    items []T,\n    id func(T) string,\n    features []func(T) float64,\n    weights []float64,\n    invert []bool,\n) ([]KDPoint[T], error)\n\n// Like BuildND but never returns an error. It performs no validation beyond\n// basic length checks and propagates NaN/Inf values from feature extractors.\nfunc BuildNDNoErr[T any](\n    items []T,\n    id func(T) string,\n    features []func(T) float64,\n    weights []float64,\n    invert []bool,\n) []KDPoint[T]\n</code></pre> <ul> <li><code>features</code>: extract raw values per axis.</li> <li><code>weights</code>: per-axis weights, same length as <code>features</code>.</li> <li><code>invert</code>: if true for an axis, uses <code>1 - normalized</code> before weighting (turns \u201chigher is better\u201d into lower cost).</li> <li>Use <code>ComputeNormStatsND</code> + <code>BuildNDWithStats</code> to reuse normalization between updates.</li> </ul> <p>Example:</p> <pre><code>pts := poindexter.BuildNDNoErr(records,\n    func(r Rec) string { return r.ID },\n    []func(Rec) float64{\n        func(r Rec) float64 { return r.PingMS },\n        func(r Rec) float64 { return r.Hops },\n        func(r Rec) float64 { return r.GeoKM },\n        func(r Rec) float64 { return r.Score },\n    },\n    []float64{1.0, 0.7, 0.2, 1.2},\n    []bool{false, false, false, true},\n)\n</code></pre>"},{"location":"api/#kdtree-backend-selection","title":"KDTree Backend selection","text":"<p>Poindexter provides two internal backends for KDTree queries:</p> <ul> <li><code>linear</code>: always available; performs O(n) scans for <code>Nearest</code>, <code>KNearest</code>, and <code>Radius</code>.</li> <li><code>gonum</code>: optimized KD backend compiled when you build with the <code>gonum</code> build tag; typically sub-linear on prunable datasets and modest dimensions.</li> </ul>"},{"location":"api/#types-and-options","title":"Types and options","text":"<pre><code>// KDBackend selects the internal engine used by KDTree.\ntype KDBackend string\n\nconst (\n    BackendLinear KDBackend = \"linear\"\n    BackendGonum  KDBackend = \"gonum\"\n)\n\n// WithBackend selects the internal KDTree backend (\"linear\" or \"gonum\").\n// If the requested backend is unavailable (e.g., missing build tag), the constructor\n// falls back to the linear backend.\nfunc WithBackend(b KDBackend) KDOption\n</code></pre>"},{"location":"api/#default-selection","title":"Default selection","text":"<ul> <li>Default is <code>linear</code>.</li> <li>If you build your project with <code>-tags=gonum</code>, the default becomes <code>gonum</code>.</li> </ul>"},{"location":"api/#usage-examples","title":"Usage examples","text":"<pre><code>// Default metric is Euclidean; you can override with WithMetric.\npts := []poindexter.KDPoint[string]{\n    {ID: \"A\", Coords: []float64{0, 0}},\n    {ID: \"B\", Coords: []float64{1, 0}},\n}\n\n// Force Linear (always available)\nlin, _ := poindexter.NewKDTree(pts, poindexter.WithBackend(poindexter.BackendLinear))\n_, _, _ = lin.Nearest([]float64{0.9, 0.1})\n\n// Force Gonum (requires building with: go build -tags=gonum)\ngon, _ := poindexter.NewKDTree(pts, poindexter.WithBackend(poindexter.BackendGonum))\n_, _, _ = gon.Nearest([]float64{0.9, 0.1})\n</code></pre>"},{"location":"api/#supported-metrics-in-the-optimized-backend","title":"Supported metrics in the optimized backend","text":"<ul> <li>Euclidean (L2), Manhattan (L1), Chebyshev (L\u221e).</li> <li>Cosine and Weighted-Cosine currently use the Linear backend.</li> </ul> <p>See also the Performance guide for measured comparisons and guidance: <code>docs/perf.md</code>.</p>"},{"location":"dht-best-ping/","title":"Example: Find the best (lowest\u2011ping) peer in a DHT table","text":"<p>This example shows how to model a \"made up\" DHT routing table and use Poindexter's <code>KDTree</code> to quickly find:</p> <ul> <li>the single best peer by ping (nearest neighbor)</li> <li>the top N best peers by ping (k\u2011nearest neighbors)</li> <li>all peers under a ping threshold (radius search)</li> </ul> <p>We keep it simple by mapping each peer to a 1\u2011dimensional coordinate: its ping in milliseconds. Using 1D means the KDTree's distance is just the absolute difference between pings.</p> <p>Tip: In a real system, you might expand to multiple dimensions (e.g., <code>[ping_ms, hop_count, geo_distance, score]</code>) and choose a metric (<code>L1</code>, <code>L2</code>, or <code>L\u221e</code>) that best matches your routing heuristic. See how to build normalized, weighted multi\u2011dimensional points with the public helpers <code>poindexter.Build2D/3D/4D</code> here: Multi-Dimensional KDTree (DHT).</p>"},{"location":"dht-best-ping/#full-example","title":"Full example","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    poindexter \"github.com/Snider/Poindexter\"\n)\n\n// Peer is our DHT peer entry (made up for this example).\ntype Peer struct {\n    Addr string // multiaddr or host:port\n    Ping int    // measured ping in milliseconds\n}\n\nfunc main() {\n    // A toy DHT routing table with made-up ping values\n    table := []Peer{\n        {Addr: \"peer1.example:4001\", Ping: 74},\n        {Addr: \"peer2.example:4001\", Ping: 52},\n        {Addr: \"peer3.example:4001\", Ping: 110},\n        {Addr: \"peer4.example:4001\", Ping: 35},\n        {Addr: \"peer5.example:4001\", Ping: 60},\n        {Addr: \"peer6.example:4001\", Ping: 44},\n    }\n\n    // Map peers to KD points in 1D where coordinate = ping (ms).\n    // Use stable string IDs so we can delete/update later.\n    pts := make([]poindexter.KDPoint[Peer], 0, len(table))\n    for i, p := range table {\n        pts = append(pts, poindexter.KDPoint[Peer]{\n            ID:     fmt.Sprintf(\"peer-%d\", i+1),\n            Coords: []float64{float64(p.Ping)},\n            Value:  p,\n        })\n    }\n\n    // Build a KDTree. Euclidean metric is fine for 1D ping comparisons.\n    kdt, err := poindexter.NewKDTree(pts, poindexter.WithMetric(poindexter.EuclideanDistance{}))\n    if err != nil {\n        panic(err)\n    }\n\n    // 1) Find the best (lowest-ping) peer.\n    //    Query is a 1D point representing desired ping target. Using 0 finds the min.\n    best, d, ok := kdt.Nearest([]float64{0})\n    if !ok {\n        fmt.Println(\"no peers found\")\n        return\n    }\n    fmt.Printf(\"Best peer: %s (ping=%d ms), distance=%.0f\\n\", best.Value.Addr, best.Value.Ping, d)\n    // Example output: Best peer: peer4.example:4001 (ping=35 ms), distance=35\n\n    // 2) Top-N best peers by ping.\n    top, dists := kdt.KNearest([]float64{0}, 3)\n    fmt.Println(\"Top 3 peers by ping:\")\n    for i := range top {\n        fmt.Printf(\"  #%d %s (ping=%d ms), distance=%.0f\\n\", i+1, top[i].Value.Addr, top[i].Value.Ping, dists[i])\n    }\n\n    // 3) All peers under a threshold (e.g., &lt;= 50 ms): radius search.\n    within, wd := kdt.Radius([]float64{0}, 50)\n    fmt.Println(\"Peers with ping &lt;= 50 ms:\")\n    for i := range within {\n        fmt.Printf(\"  %s (ping=%d ms), distance=%.0f\\n\", within[i].Value.Addr, within[i].Value.Ping, wd[i])\n    }\n\n    // 4) Dynamic updates: if a peer improves ping, we can delete &amp; re-insert with a new ID\n    //    (or keep the same ID and just update the point if your application tracks indices).\n    //    Here we simulate peer5 dropping from 60 ms to 30 ms.\n    if kdt.DeleteByID(\"peer-5\") {\n        improved := poindexter.KDPoint[Peer]{\n            ID:     \"peer-5\", // keep the same ID for simplicity\n            Coords: []float64{30},\n            Value:  Peer{Addr: \"peer5.example:4001\", Ping: 30},\n        }\n        _ = kdt.Insert(improved)\n    }\n\n    // Recompute the best after update\n    best2, d2, _ := kdt.Nearest([]float64{0})\n    fmt.Printf(\"After update, best peer: %s (ping=%d ms), distance=%.0f\\n\", best2.Value.Addr, best2.Value.Ping, d2)\n}\n</code></pre>"},{"location":"dht-best-ping/#why-does-querying-with-0-work","title":"Why does querying with <code>[0]</code> work?","text":"<p>We use Euclidean distance in 1D, so <code>distance = |ping - target|</code>. With target <code>0</code>, minimizing the distance is equivalent to minimizing the ping itself.</p>"},{"location":"dht-best-ping/#extending-the-metricspace","title":"Extending the metric/space","text":"<ul> <li>Multi-objective: encode more routing features (lower is better) as extra dimensions, e.g. <code>[ping_ms, hops, queue_delay_ms]</code>.</li> <li>Metric choice:</li> <li><code>EuclideanDistance</code> (L2): balances outliers smoothly.</li> <li><code>ManhattanDistance</code> (L1): linear penalty; robust for sparsity.</li> <li><code>ChebyshevDistance</code> (L\u221e): cares about the worst dimension.</li> <li>Normalization: when mixing units (ms, hops, km), normalize or weight dimensions so the metric reflects your priority.</li> </ul>"},{"location":"dht-best-ping/#notes","title":"Notes","text":"<ul> <li>This KDTree currently uses an internal linear scan for queries. The API is stable and designed so it can be swapped to use <code>gonum.org/v1/gonum/spatial/kdtree</code> under the hood later for sub-linear queries on large datasets.</li> <li>IDs are optional but recommended for O(1)-style deletes; keep them unique per tree.</li> </ul>"},{"location":"getting-started/","title":"Getting Started","text":"<p>This guide will help you get started with the Poindexter library.</p>"},{"location":"getting-started/#installation","title":"Installation","text":"<p>To install Poindexter, use <code>go get</code>:</p> <pre><code>go get github.com/Snider/Poindexter\n</code></pre>"},{"location":"getting-started/#basic-usage","title":"Basic Usage","text":""},{"location":"getting-started/#importing-the-library","title":"Importing the Library","text":"<pre><code>import \"github.com/Snider/Poindexter\"\n</code></pre>"},{"location":"getting-started/#using-the-hello-function","title":"Using the Hello Function","text":"<p>The <code>Hello</code> function returns a greeting message:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"github.com/Snider/Poindexter\"\n)\n\nfunc main() {\n    // Say hello to the world\n    fmt.Println(poindexter.Hello(\"\"))\n    // Output: Hello, World!\n\n    // Say hello to someone specific\n    fmt.Println(poindexter.Hello(\"Poindexter\"))\n    // Output: Hello, Poindexter!\n}\n</code></pre>"},{"location":"getting-started/#getting-the-version","title":"Getting the Version","text":"<p>You can check the library version:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"github.com/Snider/Poindexter\"\n)\n\nfunc main() {\n    version := poindexter.Version()\n    fmt.Println(\"Library version:\", version)\n}\n</code></pre>"},{"location":"getting-started/#sorting-data","title":"Sorting Data","text":"<p>Poindexter includes comprehensive sorting utilities:</p>"},{"location":"getting-started/#basic-sorting","title":"Basic Sorting","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"github.com/Snider/Poindexter\"\n)\n\nfunc main() {\n    // Sort integers\n    numbers := []int{3, 1, 4, 1, 5, 9}\n    poindexter.SortInts(numbers)\n    fmt.Println(numbers) // [1 1 3 4 5 9]\n\n    // Sort strings\n    words := []string{\"banana\", \"apple\", \"cherry\"}\n    poindexter.SortStrings(words)\n    fmt.Println(words) // [apple banana cherry]\n}\n</code></pre>"},{"location":"getting-started/#advanced-sorting-with-custom-keys","title":"Advanced Sorting with Custom Keys","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"github.com/Snider/Poindexter\"\n)\n\ntype Product struct {\n    Name  string\n    Price float64\n}\n\nfunc main() {\n    products := []Product{\n        {\"Apple\", 1.50},\n        {\"Banana\", 0.75},\n        {\"Cherry\", 3.00},\n    }\n\n    // Sort by price using SortByKey\n    poindexter.SortByKey(products, func(p Product) float64 {\n        return p.Price\n    })\n\n    for _, p := range products {\n        fmt.Printf(\"%s: $%.2f\\n\", p.Name, p.Price)\n    }\n}\n</code></pre>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Check out the API Reference for detailed documentation</li> <li>Try the example: Find the best (lowest\u2011ping) DHT peer</li> <li>Explore multidimensional KDTree over ping/hops/geo/score: Multidimensional KDTree (DHT)</li> <li>Read about the License</li> </ul>"},{"location":"kdtree-multidimensional/","title":"KDTree: Multi\u2011Dimensional Search (DHT peers)","text":"<p>This example extends the single\u2011dimension \"best ping\" demo to a realistic multi\u2011dimensional selection:</p> <ul> <li>ping_ms (lower is better)</li> <li>hop_count (lower is better)</li> <li>geo_distance_km (lower is better)</li> <li>score (higher is better \u2014 e.g., capacity/reputation)</li> </ul> <p>We will: - Build 4\u2011D points over these features - Run <code>Nearest</code>, <code>KNearest</code>, and <code>Radius</code> queries - Show subsets: ping+hop (2\u2011D) and ping+hop+geo (3\u2011D) - Demonstrate weighting/normalization to balance disparate units</p> <p>Tip: KDTree distances are geometric. Mixing units (ms, hops, km, arbitrary score) requires scaling so that each axis contributes proportionally to your decision policy.</p>"},{"location":"kdtree-multidimensional/#dataset","title":"Dataset","text":"<p>We\u2019ll use a small, made\u2011up set of DHT peers in each runnable example below. Each example declares its own <code>Peer</code> type and dataset so you can copy\u2011paste and run independently.</p>"},{"location":"kdtree-multidimensional/#normalization-and-weights","title":"Normalization and weights","text":"<p>To make heterogeneous units comparable (ms, hops, km, score), use the library helpers which: - Min\u2011max normalize each axis to [0,1] over your provided dataset - Optionally invert axes where \u201chigher is better\u201d so they become \u201clower cost\u201d - Apply per\u2011axis weights so you can emphasize what matters</p> <p>Build 4\u2011D points and query them with helpers (full program):</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    poindexter \"github.com/Snider/Poindexter\"\n)\n\ntype Peer struct {\n    ID        string\n    PingMS    float64\n    Hops      float64\n    GeoKM     float64\n    Score     float64\n}\n\nvar peers = []Peer{\n    {ID: \"A\", PingMS: 22, Hops: 3, GeoKM: 1200, Score: 0.86},\n    {ID: \"B\", PingMS: 34, Hops: 2, GeoKM: 800,  Score: 0.91},\n    {ID: \"C\", PingMS: 15, Hops: 4, GeoKM: 4500, Score: 0.70},\n    {ID: \"D\", PingMS: 55, Hops: 1, GeoKM: 300,  Score: 0.95},\n    {ID: \"E\", PingMS: 18, Hops: 2, GeoKM: 2200, Score: 0.80},\n}\n\nfunc main() {\n    // Build 4\u2011D KDTree using Euclidean (L2)\n    weights4 := [4]float64{1.0, 0.7, 0.2, 1.2}\n    invert4 := [4]bool{false, false, false, true} // invert score (higher is better)\n    pts, err := poindexter.Build4D(\n        peers,\n        func(p Peer) string { return p.ID },\n        func(p Peer) float64 { return p.PingMS },\n        func(p Peer) float64 { return p.Hops },\n        func(p Peer) float64 { return p.GeoKM },\n        func(p Peer) float64 { return p.Score },\n        weights4, invert4,\n    )\n    if err != nil { panic(err) }\n    tree, _ := poindexter.NewKDTree(pts, poindexter.WithMetric(poindexter.EuclideanDistance{}))\n\n    // Query target preferences (construct a query in normalized/weighted space)\n    // Example: seek very low ping, low hops, moderate geo, high score (low score_cost)\n    query := []float64{weights4[0]*0.0, weights4[1]*0.2, weights4[2]*0.3, weights4[3]*0.0}\n\n    // 1\u2011NN\n    best, dist, ok := tree.Nearest(query)\n    if ok {\n        fmt.Printf(\"Best peer: %s (dist=%.4f)\\n\", best.ID, dist)\n    }\n\n    // k\u2011NN (top 3)\n    neigh, dists := tree.KNearest(query, 3)\n    for i := range neigh {\n        fmt.Printf(\"%d) %s dist=%.4f\\n\", i+1, neigh[i].ID, dists[i])\n    }\n\n    // Radius query\n    within, wd := tree.Radius(query, 0.35)\n    fmt.Printf(\"Within radius 0.35: \")\n    for i := range within {\n        fmt.Printf(\"%s(%.3f) \", within[i].ID, wd[i])\n    }\n    fmt.Println()\n}\n</code></pre>"},{"location":"kdtree-multidimensional/#2d-ping-hop","title":"2\u2011D: Ping + Hop","text":"<p>Sometimes you want a strict trade\u2011off between just latency and path length. Build 2\u2011D points using helpers:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    poindexter \"github.com/Snider/Poindexter\"\n)\n\ntype Peer struct {\n    ID     string\n    PingMS float64\n    Hops   float64\n}\n\nvar peers = []Peer{\n    {ID: \"A\", PingMS: 22, Hops: 3},\n    {ID: \"B\", PingMS: 34, Hops: 2},\n    {ID: \"C\", PingMS: 15, Hops: 4},\n    {ID: \"D\", PingMS: 55, Hops: 1},\n    {ID: \"E\", PingMS: 18, Hops: 2},\n}\n\nfunc main() {\n    weights2 := [2]float64{1.0, 1.0}\n    invert2  := [2]bool{false, false}\n\n    pts2, err := poindexter.Build2D(\n        peers,\n        func(p Peer) string { return p.ID },     // id\n        func(p Peer) float64 { return p.PingMS },// f1: ping\n        func(p Peer) float64 { return p.Hops },  // f2: hops\n        weights2, invert2,\n    )\n    if err != nil { panic(err) }\n\n    tree2, _ := poindexter.NewKDTree(pts2, poindexter.WithMetric(poindexter.ManhattanDistance{})) // L1 favors axis\u2011aligned tradeoffs\n    // Prefer very low ping, modest hops\n    query2 := []float64{weights2[0]*0.0, weights2[1]*0.3}\n    best2, _, _ := tree2.Nearest(query2)\n    fmt.Println(\"2D best (ping+hop):\", best2.ID)\n}\n</code></pre>"},{"location":"kdtree-multidimensional/#3d-ping-hop-geo","title":"3\u2011D: Ping + Hop + Geo","text":"<p>Add geography to discourage far peers when latency is similar. Use the 3\u2011D helper:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    poindexter \"github.com/Snider/Poindexter\"\n)\n\ntype Peer struct {\n    ID     string\n    PingMS float64\n    Hops   float64\n    GeoKM  float64\n}\n\nvar peers = []Peer{\n    {ID: \"A\", PingMS: 22, Hops: 3, GeoKM: 1200},\n    {ID: \"B\", PingMS: 34, Hops: 2, GeoKM: 800},\n    {ID: \"C\", PingMS: 15, Hops: 4, GeoKM: 4500},\n    {ID: \"D\", PingMS: 55, Hops: 1, GeoKM: 300},\n    {ID: \"E\", PingMS: 18, Hops: 2, GeoKM: 2200},\n}\n\nfunc main() {\n    weights3 := [3]float64{1.0, 0.7, 0.3}\n    invert3  := [3]bool{false, false, false}\n\n    pts3, err := poindexter.Build3D(\n        peers,\n        func(p Peer) string { return p.ID },\n        func(p Peer) float64 { return p.PingMS },\n        func(p Peer) float64 { return p.Hops },\n        func(p Peer) float64 { return p.GeoKM },\n        weights3, invert3,\n    )\n    if err != nil { panic(err) }\n\n    tree3, _ := poindexter.NewKDTree(pts3, poindexter.WithMetric(poindexter.EuclideanDistance{}))\n    // Prefer low ping/hop, modest geo\n    query3 := []float64{weights3[0]*0.0, weights3[1]*0.2, weights3[2]*0.4}\n    top3, _, _ := tree3.Nearest(query3)\n    fmt.Println(\"3D best (ping+hop+geo):\", top3.ID)\n}\n</code></pre>"},{"location":"kdtree-multidimensional/#dynamic-updates","title":"Dynamic updates","text":"<p>Your routing table changes constantly. Insert/remove peers. For consistent normalization, compute and reuse your min/max stats (preferred) or rebuild points when the candidate set changes.</p> <p>Tip: Use the WithStats helpers to reuse normalization across updates:</p> <pre><code>// Compute once over your baseline\nstats := poindexter.ComputeNormStats2D(peers,\n    func(p Peer) float64 { return p.PingMS },\n    func(p Peer) float64 { return p.Hops },\n)\n\n// Build now or later using the same stats\nts, _ := poindexter.Build2DWithStats(\n    peers,\n    func(p Peer) string { return p.ID },\n    func(p Peer) float64 { return p.PingMS },\n    func(p Peer) float64 { return p.Hops },\n    [2]float64{1,1}, [2]bool{false,false}, stats,\n)\n</code></pre> <pre><code>package main\n\nimport (\n    \"fmt\"\n    poindexter \"github.com/Snider/Poindexter\"\n)\n\ntype Peer struct {\n    ID     string\n    PingMS float64\n    Hops   float64\n}\n\nvar peers = []Peer{\n    {ID: \"A\", PingMS: 22, Hops: 3},\n    {ID: \"B\", PingMS: 34, Hops: 2},\n    {ID: \"C\", PingMS: 15, Hops: 4},\n}\n\nfunc main() {\n    // Initial 2\u2011D build (ping + hops)\n    weights2 := [2]float64{1.0, 1.0}\n    invert2  := [2]bool{false, false}\n\n    // Compute normalization stats once over your baseline set\n    stats := poindexter.ComputeNormStats2D(\n        peers,\n        func(p Peer) float64 { return p.PingMS },\n        func(p Peer) float64 { return p.Hops },\n    )\n\n    // Build using the precomputed stats so future inserts share the same scale\n    pts, _ := poindexter.Build2DWithStats(\n        peers,\n        func(p Peer) string { return p.ID },\n        func(p Peer) float64 { return p.PingMS },\n        func(p Peer) float64 { return p.Hops },\n        weights2, invert2, stats,\n    )\n    tree, _ := poindexter.NewKDTree(pts)\n\n    // Insert a new peer: reuse the same normalization stats to keep scale consistent\n    newPeer := Peer{ID: \"Z\", PingMS: 12, Hops: 2}\n    addPts, _ := poindexter.Build2DWithStats(\n        []Peer{newPeer},\n        func(p Peer) string { return p.ID },\n        func(p Peer) float64 { return p.PingMS },\n        func(p Peer) float64 { return p.Hops },\n        weights2, invert2, stats,\n    )\n    _ = tree.Insert(addPts[0])\n\n    // Verify nearest now prefers Z for low ping target\n    best, _, _ := tree.Nearest([]float64{0, 0})\n    fmt.Println(\"Best after insert:\", best.ID)\n\n    // Delete by ID when peer goes offline\n    _ = tree.DeleteByID(\"Z\")\n}\n</code></pre>"},{"location":"kdtree-multidimensional/#choosing-a-metric","title":"Choosing a metric","text":"<ul> <li>Euclidean (L2): smooth trade\u2011offs across axes; good default for blended preferences</li> <li>Manhattan (L1): emphasizes per\u2011axis absolute differences; useful when each unit of ping/hop matters equally</li> <li>Chebyshev (L\u221e): min\u2011max style; dominated by the worst axis (e.g., reject any peer with too many hops regardless of ping)</li> </ul>"},{"location":"kdtree-multidimensional/#notes-on-production-use","title":"Notes on production use","text":"<ul> <li>Keep and reuse normalization parameters (min/max or mean/std) rather than recomputing per query to avoid drift.</li> <li>Consider capping outliers (e.g., clamp geo distances &gt; 5000 km).</li> <li>For large N (\u2265 1e5) and low dims (\u2264 8), consider swapping the internal engine to <code>gonum.org/v1/gonum/spatial/kdtree</code> behind the same API for faster queries.</li> </ul>"},{"location":"license/","title":"License","text":"<p>This project is licensed under the European Union Public Licence v1.2 (EUPL-1.2).</p>"},{"location":"license/#about-eupl-12","title":"About EUPL-1.2","text":"<p>The European Union Public Licence (EUPL) is a copyleft free/open source software license created on the initiative of and approved by the European Commission.</p>"},{"location":"license/#key-points","title":"Key Points","text":"<ul> <li>Open Source: The EUPL is an OSI-approved open source license</li> <li>Copyleft: Derivative works must be distributed under the same or compatible license</li> <li>Multilingual: The license is available in all official EU languages</li> <li>Compatible: Compatible with other major open source licenses including GPL</li> </ul>"},{"location":"license/#full-license-text","title":"Full License Text","text":"<p>The complete license text can be found in the LICENSE file in the repository.</p>"},{"location":"license/#using-eupl-12-licensed-code","title":"Using EUPL-1.2 Licensed Code","text":"<p>When using this library:</p> <ol> <li>You must retain copyright and license notices</li> <li>You must state significant changes made to the code</li> <li>Derivative works must be licensed under EUPL-1.2 or a compatible license</li> </ol>"},{"location":"license/#more-information","title":"More Information","text":"<p>For more information about the EUPL, visit: - Official EUPL Website - EUPL on Wikipedia</p>"},{"location":"perf/","title":"Performance: KDTree benchmarks and guidance","text":"<p>This page summarizes how to measure KDTree performance in this repository and how to compare the two internal backends (Linear vs Gonum) that you can select at build/runtime.</p>"},{"location":"perf/#how-benchmarks-are-organized","title":"How benchmarks are organized","text":"<ul> <li>Micro-benchmarks live in <code>bench_kdtree_test.go</code>, <code>bench_kdtree_dual_test.go</code>, and <code>bench_kdtree_dual_100k_test.go</code> and cover:</li> <li><code>Nearest</code> in 2D and 4D with N = 1k, 10k (both backends)</li> <li><code>Nearest</code> in 2D and 4D with N = 100k (gonum-tag job; linear also measured there)</li> <li><code>KNearest(k=10)</code> in 2D/4D with N = 1k, 10k</li> <li><code>Radius</code> (mid radius r\u22480.5 after normalization) in 2D/4D with N = 1k, 10k</li> <li>Datasets: Uniform and 3-cluster synthetic generators in normalized [0,1] spaces.</li> <li>Backends: Linear (always available) and Gonum (enabled when built with <code>-tags=gonum</code>).</li> </ul> <p>Run them locally:</p> <pre><code># Linear backend (default)\ngo test -bench . -benchmem -run=^$ ./...\n\n# Gonum backend (optimized KD; requires build tag)\ngo test -tags=gonum -bench . -benchmem -run=^$ ./...\n</code></pre> <p>GitHub Actions publishes benchmark artifacts on every push/PR: - Linear job: artifact <code>bench-linear.txt</code> - Gonum job: artifact <code>bench-gonum.txt</code></p>"},{"location":"perf/#backend-selection-and-defaults","title":"Backend selection and defaults","text":"<ul> <li>Default backend is Linear.</li> <li>If you build with <code>-tags=gonum</code>, the default switches to the optimized KD backend.</li> <li>You can override at runtime:</li> </ul> <pre><code>// Force Linear\nkdt, _ := poindexter.NewKDTree(pts, poindexter.WithBackend(poindexter.BackendLinear))\n// Force Gonum (requires build tag)\nkdt, _ := poindexter.NewKDTree(pts, poindexter.WithBackend(poindexter.BackendGonum))\n</code></pre> <p>Supported metrics in the optimized backend: L2 (Euclidean), L1 (Manhattan), L\u221e (Chebyshev). Cosine/Weighted-Cosine currently use the Linear backend.</p>"},{"location":"perf/#what-to-expect-rule-of-thumb","title":"What to expect (rule of thumb)","text":"<ul> <li>Linear backend: O(n) per query; fast for small-to-medium datasets (\u226410k), especially in low dims (\u22644).</li> <li>Gonum backend: typically sub-linear for prunable datasets and dims \u2264 ~8, with noticeable gains as N grows (\u226510k\u2013100k), especially on uniform or moderately clustered data and moderate radii.</li> <li>For large radii (many points within r) or highly correlated/pathological data, pruning may be less effective and behavior approaches O(n) even with KD-trees.</li> </ul>"},{"location":"perf/#interpreting-results","title":"Interpreting results","text":"<p>Benchmarks output something like:</p> <pre><code>BenchmarkNearest_10k_4D_Gonum_Uniform-8   50000  12,300 ns/op   0 B/op   0 allocs/op\n</code></pre> <ul> <li><code>ns/op</code>: lower is better (nanoseconds per operation)</li> <li><code>B/op</code> and <code>allocs/op</code>: memory behavior; fewer is better</li> <li><code>KNearest</code> incurs extra work due to sorting; <code>Radius</code> cost scales with the number of hits.</li> </ul>"},{"location":"perf/#improving-performance","title":"Improving performance","text":"<ul> <li>Normalize and weight features once; reuse across queries (see <code>Build*WithStats</code> helpers).</li> <li>Choose a metric aligned with your policy: L2 usually a solid default; L1 for per-axis penalties; L\u221e for hard-threshold dominated objectives.</li> <li>Batch queries to benefit from CPU caches.</li> <li>Prefer the Gonum backend for larger N and dims \u2264 ~8; stick to Linear for tiny datasets or when using Cosine metrics.</li> </ul>"},{"location":"perf/#reproducing-and-tracking-performance","title":"Reproducing and tracking performance","text":"<ul> <li>Local (Linear): <code>go test -bench . -benchmem -run=^$ ./...</code></li> <li>Local (Gonum): <code>go test -tags=gonum -bench . -benchmem -run=^$ ./...</code></li> <li>CI artifacts: download <code>bench-linear.txt</code> and <code>bench-gonum.txt</code> from the latest workflow run.</li> <li>Optional: add historical trend graphs via Benchstat or Codecov integration.</li> </ul>"},{"location":"wasm/","title":"Browser/WebAssembly (WASM)","text":"<p>Poindexter ships a browser build compiled to WebAssembly along with a small JS loader and TypeScript types. This allows you to use the KD\u2011Tree functionality directly from web apps (Angular, React, Vue, plain ESM, etc.).</p>"},{"location":"wasm/#whats-included","title":"What\u2019s included","text":"<ul> <li><code>dist/poindexter.wasm</code> \u2014 the compiled Go WASM module</li> <li><code>dist/wasm_exec.js</code> \u2014 Go\u2019s runtime shim required to run WASM in the browser</li> <li><code>npm/poindexter-wasm/loader.js</code> \u2014 ESM loader that instantiates the WASM and exposes a friendly API</li> <li><code>npm/poindexter-wasm/index.d.ts</code> \u2014 TypeScript typings for the loader and KD\u2011Tree API</li> </ul>"},{"location":"wasm/#quick-start","title":"Quick start","text":"<ul> <li>Build artifacts and copy <code>wasm_exec.js</code>:</li> </ul> <pre><code>make wasm-build\n</code></pre> <ul> <li>Prepare the npm package folder with <code>dist/</code> and docs:</li> </ul> <pre><code>make npm-pack\n</code></pre> <ul> <li>Minimal browser ESM usage (serve <code>dist/</code> statically):</li> </ul> <pre><code>&lt;script type=\"module\"&gt;\n  import { init } from '/npm/poindexter-wasm/loader.js';\n  const px = await init({\n    wasmURL: '/dist/poindexter.wasm',\n    wasmExecURL: '/dist/wasm_exec.js',\n  });\n  const tree = await px.newTree(2);\n  await tree.insert({ id: 'a', coords: [0, 0], value: 'A' });\n  const nn = await tree.nearest([0.1, 0.2]);\n  console.log(nn);\n&lt;/script&gt;\n</code></pre>"},{"location":"wasm/#building-locally","title":"Building locally","text":"<pre><code>make wasm-build\n</code></pre> <p>This produces <code>dist/poindexter.wasm</code> and copies <code>wasm_exec.js</code> into <code>dist/</code> from your Go installation. If your environment is non\u2011standard, you can override the path:</p> <pre><code>WASM_EXEC=/custom/path/wasm_exec.js make wasm-build\n</code></pre> <p>To assemble the npm package folder with the built artifacts:</p> <pre><code>make npm-pack\n</code></pre> <p>This populates <code>npm/poindexter-wasm/</code> with <code>dist/</code>, licence and readme files. You can then create a tarball for local testing:</p> <pre><code>npm pack ./npm/poindexter-wasm\n</code></pre>"},{"location":"wasm/#using-in-angular-example","title":"Using in Angular (example)","text":"<p>1) Install the package (use the tarball generated above or a published version):</p> <pre><code>npm install &lt;path-to&gt;/snider-poindexter-wasm-0.0.0-development.tgz\n# or once published\nnpm install @snider/poindexter-wasm\n</code></pre> <p>2) Make the WASM runtime files available as app assets. In <code>angular.json</code> under <code>build.options.assets</code>:</p> <pre><code>{\n  \"glob\": \"**/*\",\n  \"input\": \"node_modules/@snider/poindexter-wasm/dist\",\n  \"output\": \"/assets/poindexter/\"\n}\n</code></pre> <p>3) Import and initialize in your code:</p> <pre><code>import { init } from '@snider/poindexter-wasm';\n\nconst px = await init({\n  // If you used the assets mapping above, these defaults should work:\n  wasmURL: '/assets/poindexter/poindexter.wasm',\n  wasmExecURL: '/assets/poindexter/wasm_exec.js',\n});\n\nconst tree = await px.newTree(2);\nawait tree.insert({ id: 'a', coords: [0, 0], value: 'A' });\nconst nearest = await tree.nearest([0.1, 0.2]);\nconsole.log(nearest);\n</code></pre>"},{"location":"wasm/#javascript-api","title":"JavaScript API","text":"<p>Top\u2011level functions returned by <code>init()</code>:</p> <ul> <li><code>version(): string</code></li> <li><code>hello(name?: string): string</code></li> <li><code>newTree(dim: number): Promise&lt;Tree&gt;</code></li> </ul> <p>Tree methods:</p> <ul> <li><code>dim(): Promise&lt;number&gt;</code></li> <li><code>len(): Promise&lt;number&gt;</code></li> <li><code>insert(p: { id: string; coords: number[]; value?: string }): Promise&lt;void&gt;</code></li> <li><code>deleteByID(id: string): Promise&lt;boolean&gt;</code></li> <li><code>nearest(query: number[]): Promise&lt;{ id: string; coords: number[]; value: string; dist: number } | null&gt;</code></li> <li><code>kNearest(query: number[], k: number): Promise&lt;Array&lt;{ id: string; coords: number[]; value: string; dist: number }&gt;&gt;</code></li> <li><code>radius(query: number[], r: number): Promise&lt;Array&lt;{ id: string; coords: number[]; value: string; dist: number }&gt;&gt;</code></li> <li><code>exportJSON(): Promise&lt;string&gt;</code></li> </ul> <p>Notes: - The WASM bridge currently uses <code>KDTree[string]</code> for values to keep the boundary simple. You can encode richer payloads as JSON strings if needed. - <code>wasm_exec.js</code> must be available next to the <code>.wasm</code> file (the loader accepts explicit URLs if you place them elsewhere).</p>"},{"location":"wasm/#ci-artifacts","title":"CI artifacts","text":"<p>Our CI builds and uploads the following artifacts on each push/PR:</p> <ul> <li><code>poindexter-wasm-dist</code> \u2014 the <code>dist/</code> folder containing <code>poindexter.wasm</code> and <code>wasm_exec.js</code></li> <li><code>npm-poindexter-wasm</code> \u2014 the prepared npm package folder with <code>dist/</code> and documentation</li> <li><code>npm-poindexter-wasm-tarball</code> \u2014 a <code>.tgz</code> created via <code>npm pack</code> for quick local install/testing</li> </ul> <p>You can download these artifacts from the workflow run summary in GitHub Actions.</p>"},{"location":"wasm/#browser-demo-checked-into-repo","title":"Browser demo (checked into repo)","text":"<p>There is a tiny browser demo you can load locally from this repo:</p> <ul> <li>Path: <code>examples/wasm-browser/index.html</code></li> <li>Prerequisites: run <code>make wasm-build</code> so <code>dist/poindexter.wasm</code> and <code>dist/wasm_exec.js</code> exist.</li> <li>Serve the repo root (so relative paths resolve), for example:</li> </ul> <pre><code>python3 -m http.server -b 127.0.0.1 8000\n</code></pre> <p>Then open:</p> <ul> <li>http://127.0.0.1:8000/examples/wasm-browser/</li> </ul> <p>Open the browser console to see outputs from <code>nearest</code>, <code>kNearest</code>, and <code>radius</code> queries.</p>"},{"location":"wasm/#typescript-vite-demo-local-only","title":"TypeScript + Vite demo (local-only)","text":"<p>A minimal TypeScript demo using Vite is also included:</p> <ul> <li>Path: <code>examples/wasm-browser-ts/</code></li> <li>Prerequisites: run <code>make wasm-build</code> at the repo root first.</li> <li>From the example folder:</li> </ul> <pre><code>npm install\nnpm run dev\n</code></pre> <p>Then open the URL printed by Vite (usually http://127.0.0.1:5173/) and check the browser console.</p> <p>Notes: - The dev script copies <code>dist/poindexter.wasm</code>, <code>dist/wasm_exec.js</code>, and the ESM loader into the example's <code>public/</code> folder before serving. - This example is intentionally excluded from CI to keep the pipeline lean.</p>"}]}